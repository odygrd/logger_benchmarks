{
    "argLists2Cnt": {
        "": 5,
        ", const char* arg0": 1,
        ", double arg0": 1,
        ", int arg0": 1,
        ", int arg0, double arg1, unsigned int arg2, const char* arg3": 1,
        ", unsigned long int arg0": 1
    },
    "logId2Code": {
        "__Debug32level__src47testHelper47client46cc__23__": {
            "compilationUnit": "src/testHelper/client.cc",
            "compressFnDef": "\ninline ssize_t\ncompressArgs__Debug32level__src47testHelper47client46cc__23__(NanoLogInternal::Log::UncompressedEntry *re, char* out) {\n    char *originalOutPtr = out;\n\n    // Allocate nibbles\n    BufferUtils::TwoNibbles *nib = reinterpret_cast<BufferUtils::TwoNibbles*>(out);\n    out += 0;\n\n    char *args = re->argData;\n\n    // Read back all the primitives\n    \n\n    // Pack all the primitives\n    \n\n    if (false) {\n        // memcpy all the strings without compression\n        size_t stringBytes = re->entrySize - ( 0)\n                                            - sizeof(NanoLogInternal::Log::UncompressedEntry);\n        if (stringBytes > 0) {\n            memcpy(out, args, stringBytes);\n            out += stringBytes;\n        }\n    }\n\n    return out - originalOutPtr;\n}\n",
            "compressFnName": "compressArgs__Debug32level__src47testHelper47client46cc__23__",
            "decompressFnDef": "\ninline void\ndecompressPrintArgs__Debug32level__src47testHelper47client46cc__23__ (const char **in,\n                        FILE *outputFd,\n                        void (*aggFn)(const char*, ...)) {\n    BufferUtils::TwoNibbles nib[0];\n    memcpy(&nib, (*in), 0);\n    (*in) += 0;\n\n    // Unpack all the non-string argments\n    \n\n    // Find all the strings\n    \n\n    const char *fmtString = \"Debug level\";\n    const char *filename = \"src/testHelper/client.cc\";\n    const int linenum = 23;\n    const NanoLog::LogLevel logLevel = DEBUG;\n\n    if (outputFd)\n        fprintf(outputFd, \"Debug level\" \"\\r\\n\" );\n\n    if (aggFn)\n        (*aggFn)(\"Debug level\" );\n}\n",
            "decompressFnName": "decompressPrintArgs__Debug32level__src47testHelper47client46cc__23__",
            "dictionaryFragment": "\n{\n    // src/testHelper/client.cc:23 - \"Debug level\"\n    FormatMetadata *fm;\n    PrintFragment *pf;\n    if (buffer + sizeof(FormatMetadata) + 25 >= endOfBuffer)\n        return -1;\n\n    fm = reinterpret_cast<FormatMetadata*>(buffer);\n    buffer += sizeof(FormatMetadata);\n\n    fm->numNibbles = 0;\n    fm->numPrintFragments = 1;\n    fm->logLevel = DEBUG;\n    fm->lineNumber = 23;\n    fm->filenameLength = 25;\n\n    buffer = stpcpy(buffer, \"src/testHelper/client.cc\") + 1;\n\n            // Fragment 0\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\"Debug level\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = NONE;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\"Debug level\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \"Debug level\") + 1;\n}\r\n\r\n",
            "filename": "src/testHelper/client.cc",
            "fmtString": "Debug level",
            "linenum": 23,
            "logLevel": "DEBUG",
            "recordFnDecl": "void __syang0__fl__Debug32level__src47testHelper47client46cc__23__(NanoLog::LogLevel level, const char* fmtStr )",
            "recordFnDef": "\ninline void __syang0__fl__Debug32level__src47testHelper47client46cc__23__(NanoLog::LogLevel level, const char* fmtStr ) {\n    extern const uint32_t __fmtId__Debug32level__src47testHelper47client46cc__23__;\n\n    if (level > NanoLog::getLogLevel())\n        return;\n\n    uint64_t timestamp = PerfUtils::Cycles::rdtsc();\n    ;\n    size_t allocSize =   sizeof(NanoLogInternal::Log::UncompressedEntry);\n    NanoLogInternal::Log::UncompressedEntry *re = reinterpret_cast<NanoLogInternal::Log::UncompressedEntry*>(NanoLogInternal::RuntimeLogger::reserveAlloc(allocSize));\n\n    re->fmtId = __fmtId__Debug32level__src47testHelper47client46cc__23__;\n    re->timestamp = timestamp;\n    re->entrySize = static_cast<uint32_t>(allocSize);\n\n    char *buffer = re->argData;\n\n    // Record the non-string arguments\n    \n\n    // Record the strings (if any) at the end of the entry\n    \n\n    // Make the entry visible\n    NanoLogInternal::RuntimeLogger::finishAlloc(allocSize);\n}\n",
            "recordFnName": "__syang0__fl__Debug32level__src47testHelper47client46cc__23__"
        },
        "__Error32Level__src47testHelper47client46cc__26__": {
            "compilationUnit": "src/testHelper/client.cc",
            "compressFnDef": "\ninline ssize_t\ncompressArgs__Error32Level__src47testHelper47client46cc__26__(NanoLogInternal::Log::UncompressedEntry *re, char* out) {\n    char *originalOutPtr = out;\n\n    // Allocate nibbles\n    BufferUtils::TwoNibbles *nib = reinterpret_cast<BufferUtils::TwoNibbles*>(out);\n    out += 0;\n\n    char *args = re->argData;\n\n    // Read back all the primitives\n    \n\n    // Pack all the primitives\n    \n\n    if (false) {\n        // memcpy all the strings without compression\n        size_t stringBytes = re->entrySize - ( 0)\n                                            - sizeof(NanoLogInternal::Log::UncompressedEntry);\n        if (stringBytes > 0) {\n            memcpy(out, args, stringBytes);\n            out += stringBytes;\n        }\n    }\n\n    return out - originalOutPtr;\n}\n",
            "compressFnName": "compressArgs__Error32Level__src47testHelper47client46cc__26__",
            "decompressFnDef": "\ninline void\ndecompressPrintArgs__Error32Level__src47testHelper47client46cc__26__ (const char **in,\n                        FILE *outputFd,\n                        void (*aggFn)(const char*, ...)) {\n    BufferUtils::TwoNibbles nib[0];\n    memcpy(&nib, (*in), 0);\n    (*in) += 0;\n\n    // Unpack all the non-string argments\n    \n\n    // Find all the strings\n    \n\n    const char *fmtString = \"Error Level\";\n    const char *filename = \"src/testHelper/client.cc\";\n    const int linenum = 26;\n    const NanoLog::LogLevel logLevel = ERROR;\n\n    if (outputFd)\n        fprintf(outputFd, \"Error Level\" \"\\r\\n\" );\n\n    if (aggFn)\n        (*aggFn)(\"Error Level\" );\n}\n",
            "decompressFnName": "decompressPrintArgs__Error32Level__src47testHelper47client46cc__26__",
            "dictionaryFragment": "\n{\n    // src/testHelper/client.cc:26 - \"Error Level\"\n    FormatMetadata *fm;\n    PrintFragment *pf;\n    if (buffer + sizeof(FormatMetadata) + 25 >= endOfBuffer)\n        return -1;\n\n    fm = reinterpret_cast<FormatMetadata*>(buffer);\n    buffer += sizeof(FormatMetadata);\n\n    fm->numNibbles = 0;\n    fm->numPrintFragments = 1;\n    fm->logLevel = ERROR;\n    fm->lineNumber = 26;\n    fm->filenameLength = 25;\n\n    buffer = stpcpy(buffer, \"src/testHelper/client.cc\") + 1;\n\n            // Fragment 0\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\"Error Level\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = NONE;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\"Error Level\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \"Error Level\") + 1;\n}\r\n\r\n",
            "filename": "src/testHelper/client.cc",
            "fmtString": "Error Level",
            "linenum": 26,
            "logLevel": "ERROR",
            "recordFnDecl": "void __syang0__fl__Error32Level__src47testHelper47client46cc__26__(NanoLog::LogLevel level, const char* fmtStr )",
            "recordFnDef": "\ninline void __syang0__fl__Error32Level__src47testHelper47client46cc__26__(NanoLog::LogLevel level, const char* fmtStr ) {\n    extern const uint32_t __fmtId__Error32Level__src47testHelper47client46cc__26__;\n\n    if (level > NanoLog::getLogLevel())\n        return;\n\n    uint64_t timestamp = PerfUtils::Cycles::rdtsc();\n    ;\n    size_t allocSize =   sizeof(NanoLogInternal::Log::UncompressedEntry);\n    NanoLogInternal::Log::UncompressedEntry *re = reinterpret_cast<NanoLogInternal::Log::UncompressedEntry*>(NanoLogInternal::RuntimeLogger::reserveAlloc(allocSize));\n\n    re->fmtId = __fmtId__Error32Level__src47testHelper47client46cc__26__;\n    re->timestamp = timestamp;\n    re->entrySize = static_cast<uint32_t>(allocSize);\n\n    char *buffer = re->argData;\n\n    // Record the non-string arguments\n    \n\n    // Record the strings (if any) at the end of the entry\n    \n\n    // Make the entry visible\n    NanoLogInternal::RuntimeLogger::finishAlloc(allocSize);\n}\n",
            "recordFnName": "__syang0__fl__Error32Level__src47testHelper47client46cc__26__"
        },
        "__I32have32a32couple32of32things3237d443237f443237u443237s__src47testHelper47client46cc__31__": {
            "compilationUnit": "src/testHelper/client.cc",
            "compressFnDef": "\ninline ssize_t\ncompressArgs__I32have32a32couple32of32things3237d443237f443237u443237s__src47testHelper47client46cc__31__(NanoLogInternal::Log::UncompressedEntry *re, char* out) {\n    char *originalOutPtr = out;\n\n    // Allocate nibbles\n    BufferUtils::TwoNibbles *nib = reinterpret_cast<BufferUtils::TwoNibbles*>(out);\n    out += 2;\n\n    char *args = re->argData;\n\n    // Read back all the primitives\n    \tint arg0 = *reinterpret_cast<int*>(args); args +=sizeof(int);\n\tdouble arg1 = *reinterpret_cast<double*>(args); args +=sizeof(double);\n\tunsigned int arg2 = *reinterpret_cast<unsigned int*>(args); args +=sizeof(unsigned int);\n\n\n    // Pack all the primitives\n    \tnib[0].first = 0x0f & static_cast<uint8_t>(BufferUtils::pack(&out, arg0));\n\tnib[0].second = 0x0f & static_cast<uint8_t>(BufferUtils::pack(&out, arg1));\n\tnib[1].first = 0x0f & static_cast<uint8_t>(BufferUtils::pack(&out, arg2));\n\n\n    if (true) {\n        // memcpy all the strings without compression\n        size_t stringBytes = re->entrySize - (sizeof(arg0) + sizeof(arg1) + sizeof(arg2) +  0)\n                                            - sizeof(NanoLogInternal::Log::UncompressedEntry);\n        if (stringBytes > 0) {\n            memcpy(out, args, stringBytes);\n            out += stringBytes;\n        }\n    }\n\n    return out - originalOutPtr;\n}\n",
            "compressFnName": "compressArgs__I32have32a32couple32of32things3237d443237f443237u443237s__src47testHelper47client46cc__31__",
            "decompressFnDef": "\ninline void\ndecompressPrintArgs__I32have32a32couple32of32things3237d443237f443237u443237s__src47testHelper47client46cc__31__ (const char **in,\n                        FILE *outputFd,\n                        void (*aggFn)(const char*, ...)) {\n    BufferUtils::TwoNibbles nib[2];\n    memcpy(&nib, (*in), 2);\n    (*in) += 2;\n\n    // Unpack all the non-string argments\n    \tint arg0 = BufferUtils::unpack<int>(in, nib[0].first);\n\tdouble arg1 = BufferUtils::unpack<double>(in, nib[0].second);\n\tunsigned int arg2 = BufferUtils::unpack<unsigned int>(in, nib[1].first);\n\n\n    // Find all the strings\n    \n                const char* arg3 = reinterpret_cast<const char*>(*in);\n                (*in) += (strlen(arg3) + 1)*sizeof(*arg3); // +1 for null terminator\n            \n\n    const char *fmtString = \"I have a couple of things %d, %f, %u, %s\";\n    const char *filename = \"src/testHelper/client.cc\";\n    const int linenum = 31;\n    const NanoLog::LogLevel logLevel = NOTICE;\n\n    if (outputFd)\n        fprintf(outputFd, \"I have a couple of things %d, %f, %u, %s\" \"\\r\\n\" , arg0, arg1, arg2, arg3);\n\n    if (aggFn)\n        (*aggFn)(\"I have a couple of things %d, %f, %u, %s\" , arg0, arg1, arg2, arg3);\n}\n",
            "decompressFnName": "decompressPrintArgs__I32have32a32couple32of32things3237d443237f443237u443237s__src47testHelper47client46cc__31__",
            "dictionaryFragment": "\n{\n    // src/testHelper/client.cc:31 - \"I have a couple of things %d, %f, %u, %s\"\n    FormatMetadata *fm;\n    PrintFragment *pf;\n    if (buffer + sizeof(FormatMetadata) + 25 >= endOfBuffer)\n        return -1;\n\n    fm = reinterpret_cast<FormatMetadata*>(buffer);\n    buffer += sizeof(FormatMetadata);\n\n    fm->numNibbles = 3;\n    fm->numPrintFragments = 4;\n    fm->logLevel = NOTICE;\n    fm->lineNumber = 31;\n    fm->filenameLength = 25;\n\n    buffer = stpcpy(buffer, \"src/testHelper/client.cc\") + 1;\n\n            // Fragment 0\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\"I have a couple of things %d\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = int_t;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\"I have a couple of things %d\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \"I have a couple of things %d\") + 1;\n\n            // Fragment 1\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\", %f\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = double_t;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\", %f\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \", %f\") + 1;\n\n            // Fragment 2\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\", %u\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = unsigned_int_t;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\", %u\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \", %u\") + 1;\n\n            // Fragment 3\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\", %s\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = const_char_ptr_t;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\", %s\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \", %s\") + 1;\n}\r\n\r\n",
            "filename": "src/testHelper/client.cc",
            "fmtString": "I have a couple of things %d, %f, %u, %s",
            "linenum": 31,
            "logLevel": "NOTICE",
            "recordFnDecl": "void __syang0__fl__I32have32a32couple32of32things3237d443237f443237u443237s__src47testHelper47client46cc__31__(NanoLog::LogLevel level, const char* fmtStr , int arg0, double arg1, unsigned int arg2, const char* arg3)",
            "recordFnDef": "\ninline void __syang0__fl__I32have32a32couple32of32things3237d443237f443237u443237s__src47testHelper47client46cc__31__(NanoLog::LogLevel level, const char* fmtStr , int arg0, double arg1, unsigned int arg2, const char* arg3) {\n    extern const uint32_t __fmtId__I32have32a32couple32of32things3237d443237f443237u443237s__src47testHelper47client46cc__31__;\n\n    if (level > NanoLog::getLogLevel())\n        return;\n\n    uint64_t timestamp = PerfUtils::Cycles::rdtsc();\n    size_t str3Len = 1 + strlen(arg3);;\n    size_t allocSize = sizeof(arg0) + sizeof(arg1) + sizeof(arg2) +  str3Len +  sizeof(NanoLogInternal::Log::UncompressedEntry);\n    NanoLogInternal::Log::UncompressedEntry *re = reinterpret_cast<NanoLogInternal::Log::UncompressedEntry*>(NanoLogInternal::RuntimeLogger::reserveAlloc(allocSize));\n\n    re->fmtId = __fmtId__I32have32a32couple32of32things3237d443237f443237u443237s__src47testHelper47client46cc__31__;\n    re->timestamp = timestamp;\n    re->entrySize = static_cast<uint32_t>(allocSize);\n\n    char *buffer = re->argData;\n\n    // Record the non-string arguments\n    \tNanoLogInternal::Log::recordPrimitive(buffer, arg0);\n\tNanoLogInternal::Log::recordPrimitive(buffer, arg1);\n\tNanoLogInternal::Log::recordPrimitive(buffer, arg2);\n\n\n    // Record the strings (if any) at the end of the entry\n    memcpy(buffer, arg3, str3Len); buffer += str3Len;*(reinterpret_cast<std::remove_const<typename std::remove_pointer<decltype(arg3)>::type>::type*>(buffer) - 1) = L'\\0';\n\n    // Make the entry visible\n    NanoLogInternal::RuntimeLogger::finishAlloc(allocSize);\n}\n",
            "recordFnName": "__syang0__fl__I32have32a32couple32of32things3237d443237f443237u443237s__src47testHelper47client46cc__31__"
        },
        "__I32have32a32double3237lf__src47testHelper47client46cc__30__": {
            "compilationUnit": "src/testHelper/client.cc",
            "compressFnDef": "\ninline ssize_t\ncompressArgs__I32have32a32double3237lf__src47testHelper47client46cc__30__(NanoLogInternal::Log::UncompressedEntry *re, char* out) {\n    char *originalOutPtr = out;\n\n    // Allocate nibbles\n    BufferUtils::TwoNibbles *nib = reinterpret_cast<BufferUtils::TwoNibbles*>(out);\n    out += 1;\n\n    char *args = re->argData;\n\n    // Read back all the primitives\n    \tdouble arg0 = *reinterpret_cast<double*>(args); args +=sizeof(double);\n\n\n    // Pack all the primitives\n    \tnib[0].first = 0x0f & static_cast<uint8_t>(BufferUtils::pack(&out, arg0));\n\n\n    if (false) {\n        // memcpy all the strings without compression\n        size_t stringBytes = re->entrySize - (sizeof(arg0) +  0)\n                                            - sizeof(NanoLogInternal::Log::UncompressedEntry);\n        if (stringBytes > 0) {\n            memcpy(out, args, stringBytes);\n            out += stringBytes;\n        }\n    }\n\n    return out - originalOutPtr;\n}\n",
            "compressFnName": "compressArgs__I32have32a32double3237lf__src47testHelper47client46cc__30__",
            "decompressFnDef": "\ninline void\ndecompressPrintArgs__I32have32a32double3237lf__src47testHelper47client46cc__30__ (const char **in,\n                        FILE *outputFd,\n                        void (*aggFn)(const char*, ...)) {\n    BufferUtils::TwoNibbles nib[1];\n    memcpy(&nib, (*in), 1);\n    (*in) += 1;\n\n    // Unpack all the non-string argments\n    \tdouble arg0 = BufferUtils::unpack<double>(in, nib[0].first);\n\n\n    // Find all the strings\n    \n\n    const char *fmtString = \"I have a double %lf\";\n    const char *filename = \"src/testHelper/client.cc\";\n    const int linenum = 30;\n    const NanoLog::LogLevel logLevel = NOTICE;\n\n    if (outputFd)\n        fprintf(outputFd, \"I have a double %lf\" \"\\r\\n\" , arg0);\n\n    if (aggFn)\n        (*aggFn)(\"I have a double %lf\" , arg0);\n}\n",
            "decompressFnName": "decompressPrintArgs__I32have32a32double3237lf__src47testHelper47client46cc__30__",
            "dictionaryFragment": "\n{\n    // src/testHelper/client.cc:30 - \"I have a double %lf\"\n    FormatMetadata *fm;\n    PrintFragment *pf;\n    if (buffer + sizeof(FormatMetadata) + 25 >= endOfBuffer)\n        return -1;\n\n    fm = reinterpret_cast<FormatMetadata*>(buffer);\n    buffer += sizeof(FormatMetadata);\n\n    fm->numNibbles = 1;\n    fm->numPrintFragments = 1;\n    fm->logLevel = NOTICE;\n    fm->lineNumber = 30;\n    fm->filenameLength = 25;\n\n    buffer = stpcpy(buffer, \"src/testHelper/client.cc\") + 1;\n\n            // Fragment 0\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\"I have a double %lf\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = double_t;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\"I have a double %lf\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \"I have a double %lf\") + 1;\n}\r\n\r\n",
            "filename": "src/testHelper/client.cc",
            "fmtString": "I have a double %lf",
            "linenum": 30,
            "logLevel": "NOTICE",
            "recordFnDecl": "void __syang0__fl__I32have32a32double3237lf__src47testHelper47client46cc__30__(NanoLog::LogLevel level, const char* fmtStr , double arg0)",
            "recordFnDef": "\ninline void __syang0__fl__I32have32a32double3237lf__src47testHelper47client46cc__30__(NanoLog::LogLevel level, const char* fmtStr , double arg0) {\n    extern const uint32_t __fmtId__I32have32a32double3237lf__src47testHelper47client46cc__30__;\n\n    if (level > NanoLog::getLogLevel())\n        return;\n\n    uint64_t timestamp = PerfUtils::Cycles::rdtsc();\n    ;\n    size_t allocSize = sizeof(arg0) +   sizeof(NanoLogInternal::Log::UncompressedEntry);\n    NanoLogInternal::Log::UncompressedEntry *re = reinterpret_cast<NanoLogInternal::Log::UncompressedEntry*>(NanoLogInternal::RuntimeLogger::reserveAlloc(allocSize));\n\n    re->fmtId = __fmtId__I32have32a32double3237lf__src47testHelper47client46cc__30__;\n    re->timestamp = timestamp;\n    re->entrySize = static_cast<uint32_t>(allocSize);\n\n    char *buffer = re->argData;\n\n    // Record the non-string arguments\n    \tNanoLogInternal::Log::recordPrimitive(buffer, arg0);\n\n\n    // Record the strings (if any) at the end of the entry\n    \n\n    // Make the entry visible\n    NanoLogInternal::RuntimeLogger::finishAlloc(allocSize);\n}\n",
            "recordFnName": "__syang0__fl__I32have32a32double3237lf__src47testHelper47client46cc__30__"
        },
        "__I32have32a32uint6495t3237lu__src47testHelper47client46cc__29__": {
            "compilationUnit": "src/testHelper/client.cc",
            "compressFnDef": "\ninline ssize_t\ncompressArgs__I32have32a32uint6495t3237lu__src47testHelper47client46cc__29__(NanoLogInternal::Log::UncompressedEntry *re, char* out) {\n    char *originalOutPtr = out;\n\n    // Allocate nibbles\n    BufferUtils::TwoNibbles *nib = reinterpret_cast<BufferUtils::TwoNibbles*>(out);\n    out += 1;\n\n    char *args = re->argData;\n\n    // Read back all the primitives\n    \tunsigned long int arg0 = *reinterpret_cast<unsigned long int*>(args); args +=sizeof(unsigned long int);\n\n\n    // Pack all the primitives\n    \tnib[0].first = 0x0f & static_cast<uint8_t>(BufferUtils::pack(&out, arg0));\n\n\n    if (false) {\n        // memcpy all the strings without compression\n        size_t stringBytes = re->entrySize - (sizeof(arg0) +  0)\n                                            - sizeof(NanoLogInternal::Log::UncompressedEntry);\n        if (stringBytes > 0) {\n            memcpy(out, args, stringBytes);\n            out += stringBytes;\n        }\n    }\n\n    return out - originalOutPtr;\n}\n",
            "compressFnName": "compressArgs__I32have32a32uint6495t3237lu__src47testHelper47client46cc__29__",
            "decompressFnDef": "\ninline void\ndecompressPrintArgs__I32have32a32uint6495t3237lu__src47testHelper47client46cc__29__ (const char **in,\n                        FILE *outputFd,\n                        void (*aggFn)(const char*, ...)) {\n    BufferUtils::TwoNibbles nib[1];\n    memcpy(&nib, (*in), 1);\n    (*in) += 1;\n\n    // Unpack all the non-string argments\n    \tunsigned long int arg0 = BufferUtils::unpack<unsigned long int>(in, nib[0].first);\n\n\n    // Find all the strings\n    \n\n    const char *fmtString = \"I have a uint64_t %lu\";\n    const char *filename = \"src/testHelper/client.cc\";\n    const int linenum = 29;\n    const NanoLog::LogLevel logLevel = NOTICE;\n\n    if (outputFd)\n        fprintf(outputFd, \"I have a uint64_t %lu\" \"\\r\\n\" , arg0);\n\n    if (aggFn)\n        (*aggFn)(\"I have a uint64_t %lu\" , arg0);\n}\n",
            "decompressFnName": "decompressPrintArgs__I32have32a32uint6495t3237lu__src47testHelper47client46cc__29__",
            "dictionaryFragment": "\n{\n    // src/testHelper/client.cc:29 - \"I have a uint64_t %lu\"\n    FormatMetadata *fm;\n    PrintFragment *pf;\n    if (buffer + sizeof(FormatMetadata) + 25 >= endOfBuffer)\n        return -1;\n\n    fm = reinterpret_cast<FormatMetadata*>(buffer);\n    buffer += sizeof(FormatMetadata);\n\n    fm->numNibbles = 1;\n    fm->numPrintFragments = 1;\n    fm->logLevel = NOTICE;\n    fm->lineNumber = 29;\n    fm->filenameLength = 25;\n\n    buffer = stpcpy(buffer, \"src/testHelper/client.cc\") + 1;\n\n            // Fragment 0\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\"I have a uint64_t %lu\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = unsigned_long_int_t;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\"I have a uint64_t %lu\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \"I have a uint64_t %lu\") + 1;\n}\r\n\r\n",
            "filename": "src/testHelper/client.cc",
            "fmtString": "I have a uint64_t %lu",
            "linenum": 29,
            "logLevel": "NOTICE",
            "recordFnDecl": "void __syang0__fl__I32have32a32uint6495t3237lu__src47testHelper47client46cc__29__(NanoLog::LogLevel level, const char* fmtStr , unsigned long int arg0)",
            "recordFnDef": "\ninline void __syang0__fl__I32have32a32uint6495t3237lu__src47testHelper47client46cc__29__(NanoLog::LogLevel level, const char* fmtStr , unsigned long int arg0) {\n    extern const uint32_t __fmtId__I32have32a32uint6495t3237lu__src47testHelper47client46cc__29__;\n\n    if (level > NanoLog::getLogLevel())\n        return;\n\n    uint64_t timestamp = PerfUtils::Cycles::rdtsc();\n    ;\n    size_t allocSize = sizeof(arg0) +   sizeof(NanoLogInternal::Log::UncompressedEntry);\n    NanoLogInternal::Log::UncompressedEntry *re = reinterpret_cast<NanoLogInternal::Log::UncompressedEntry*>(NanoLogInternal::RuntimeLogger::reserveAlloc(allocSize));\n\n    re->fmtId = __fmtId__I32have32a32uint6495t3237lu__src47testHelper47client46cc__29__;\n    re->timestamp = timestamp;\n    re->entrySize = static_cast<uint32_t>(allocSize);\n\n    char *buffer = re->argData;\n\n    // Record the non-string arguments\n    \tNanoLogInternal::Log::recordPrimitive(buffer, arg0);\n\n\n    // Record the strings (if any) at the end of the entry\n    \n\n    // Make the entry visible\n    NanoLogInternal::RuntimeLogger::finishAlloc(allocSize);\n}\n",
            "recordFnName": "__syang0__fl__I32have32a32uint6495t3237lu__src47testHelper47client46cc__29__"
        },
        "__I32have32an32integer3237d__src47testHelper47client46cc__28__": {
            "compilationUnit": "src/testHelper/client.cc",
            "compressFnDef": "\ninline ssize_t\ncompressArgs__I32have32an32integer3237d__src47testHelper47client46cc__28__(NanoLogInternal::Log::UncompressedEntry *re, char* out) {\n    char *originalOutPtr = out;\n\n    // Allocate nibbles\n    BufferUtils::TwoNibbles *nib = reinterpret_cast<BufferUtils::TwoNibbles*>(out);\n    out += 1;\n\n    char *args = re->argData;\n\n    // Read back all the primitives\n    \tint arg0 = *reinterpret_cast<int*>(args); args +=sizeof(int);\n\n\n    // Pack all the primitives\n    \tnib[0].first = 0x0f & static_cast<uint8_t>(BufferUtils::pack(&out, arg0));\n\n\n    if (false) {\n        // memcpy all the strings without compression\n        size_t stringBytes = re->entrySize - (sizeof(arg0) +  0)\n                                            - sizeof(NanoLogInternal::Log::UncompressedEntry);\n        if (stringBytes > 0) {\n            memcpy(out, args, stringBytes);\n            out += stringBytes;\n        }\n    }\n\n    return out - originalOutPtr;\n}\n",
            "compressFnName": "compressArgs__I32have32an32integer3237d__src47testHelper47client46cc__28__",
            "decompressFnDef": "\ninline void\ndecompressPrintArgs__I32have32an32integer3237d__src47testHelper47client46cc__28__ (const char **in,\n                        FILE *outputFd,\n                        void (*aggFn)(const char*, ...)) {\n    BufferUtils::TwoNibbles nib[1];\n    memcpy(&nib, (*in), 1);\n    (*in) += 1;\n\n    // Unpack all the non-string argments\n    \tint arg0 = BufferUtils::unpack<int>(in, nib[0].first);\n\n\n    // Find all the strings\n    \n\n    const char *fmtString = \"I have an integer %d\";\n    const char *filename = \"src/testHelper/client.cc\";\n    const int linenum = 28;\n    const NanoLog::LogLevel logLevel = NOTICE;\n\n    if (outputFd)\n        fprintf(outputFd, \"I have an integer %d\" \"\\r\\n\" , arg0);\n\n    if (aggFn)\n        (*aggFn)(\"I have an integer %d\" , arg0);\n}\n",
            "decompressFnName": "decompressPrintArgs__I32have32an32integer3237d__src47testHelper47client46cc__28__",
            "dictionaryFragment": "\n{\n    // src/testHelper/client.cc:28 - \"I have an integer %d\"\n    FormatMetadata *fm;\n    PrintFragment *pf;\n    if (buffer + sizeof(FormatMetadata) + 25 >= endOfBuffer)\n        return -1;\n\n    fm = reinterpret_cast<FormatMetadata*>(buffer);\n    buffer += sizeof(FormatMetadata);\n\n    fm->numNibbles = 1;\n    fm->numPrintFragments = 1;\n    fm->logLevel = NOTICE;\n    fm->lineNumber = 28;\n    fm->filenameLength = 25;\n\n    buffer = stpcpy(buffer, \"src/testHelper/client.cc\") + 1;\n\n            // Fragment 0\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\"I have an integer %d\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = int_t;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\"I have an integer %d\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \"I have an integer %d\") + 1;\n}\r\n\r\n",
            "filename": "src/testHelper/client.cc",
            "fmtString": "I have an integer %d",
            "linenum": 28,
            "logLevel": "NOTICE",
            "recordFnDecl": "void __syang0__fl__I32have32an32integer3237d__src47testHelper47client46cc__28__(NanoLog::LogLevel level, const char* fmtStr , int arg0)",
            "recordFnDef": "\ninline void __syang0__fl__I32have32an32integer3237d__src47testHelper47client46cc__28__(NanoLog::LogLevel level, const char* fmtStr , int arg0) {\n    extern const uint32_t __fmtId__I32have32an32integer3237d__src47testHelper47client46cc__28__;\n\n    if (level > NanoLog::getLogLevel())\n        return;\n\n    uint64_t timestamp = PerfUtils::Cycles::rdtsc();\n    ;\n    size_t allocSize = sizeof(arg0) +   sizeof(NanoLogInternal::Log::UncompressedEntry);\n    NanoLogInternal::Log::UncompressedEntry *re = reinterpret_cast<NanoLogInternal::Log::UncompressedEntry*>(NanoLogInternal::RuntimeLogger::reserveAlloc(allocSize));\n\n    re->fmtId = __fmtId__I32have32an32integer3237d__src47testHelper47client46cc__28__;\n    re->timestamp = timestamp;\n    re->entrySize = static_cast<uint32_t>(allocSize);\n\n    char *buffer = re->argData;\n\n    // Record the non-string arguments\n    \tNanoLogInternal::Log::recordPrimitive(buffer, arg0);\n\n\n    // Record the strings (if any) at the end of the entry\n    \n\n    // Make the entry visible\n    NanoLogInternal::RuntimeLogger::finishAlloc(allocSize);\n}\n",
            "recordFnName": "__syang0__fl__I32have32an32integer3237d__src47testHelper47client46cc__28__"
        },
        "__INVALID__INVALID__INVALID__": {
            "compilationUnit": "INVALID.cc",
            "compressFnDef": "invalidCompress(...) { ....}",
            "compressFnName": "invalidCompress",
            "decompressFnDef": "invalidDecompress(...) { ... }",
            "decompressFnName": "invalidDecompress",
            "dictionaryFragment": "{...}",
            "filename": "INVALID.cc",
            "fmtString": "INVALID",
            "linenum": "-1",
            "recordFnDecl": "void invalidRecord(LogLevel, ...)",
            "recordFnDef": "invalidRecord(int arg0) { ... }",
            "recordFnName": "invalidRecord"
        },
        "__Notice32Level__src47testHelper47client46cc__24__": {
            "compilationUnit": "src/testHelper/client.cc",
            "compressFnDef": "\ninline ssize_t\ncompressArgs__Notice32Level__src47testHelper47client46cc__24__(NanoLogInternal::Log::UncompressedEntry *re, char* out) {\n    char *originalOutPtr = out;\n\n    // Allocate nibbles\n    BufferUtils::TwoNibbles *nib = reinterpret_cast<BufferUtils::TwoNibbles*>(out);\n    out += 0;\n\n    char *args = re->argData;\n\n    // Read back all the primitives\n    \n\n    // Pack all the primitives\n    \n\n    if (false) {\n        // memcpy all the strings without compression\n        size_t stringBytes = re->entrySize - ( 0)\n                                            - sizeof(NanoLogInternal::Log::UncompressedEntry);\n        if (stringBytes > 0) {\n            memcpy(out, args, stringBytes);\n            out += stringBytes;\n        }\n    }\n\n    return out - originalOutPtr;\n}\n",
            "compressFnName": "compressArgs__Notice32Level__src47testHelper47client46cc__24__",
            "decompressFnDef": "\ninline void\ndecompressPrintArgs__Notice32Level__src47testHelper47client46cc__24__ (const char **in,\n                        FILE *outputFd,\n                        void (*aggFn)(const char*, ...)) {\n    BufferUtils::TwoNibbles nib[0];\n    memcpy(&nib, (*in), 0);\n    (*in) += 0;\n\n    // Unpack all the non-string argments\n    \n\n    // Find all the strings\n    \n\n    const char *fmtString = \"Notice Level\";\n    const char *filename = \"src/testHelper/client.cc\";\n    const int linenum = 24;\n    const NanoLog::LogLevel logLevel = NOTICE;\n\n    if (outputFd)\n        fprintf(outputFd, \"Notice Level\" \"\\r\\n\" );\n\n    if (aggFn)\n        (*aggFn)(\"Notice Level\" );\n}\n",
            "decompressFnName": "decompressPrintArgs__Notice32Level__src47testHelper47client46cc__24__",
            "dictionaryFragment": "\n{\n    // src/testHelper/client.cc:24 - \"Notice Level\"\n    FormatMetadata *fm;\n    PrintFragment *pf;\n    if (buffer + sizeof(FormatMetadata) + 25 >= endOfBuffer)\n        return -1;\n\n    fm = reinterpret_cast<FormatMetadata*>(buffer);\n    buffer += sizeof(FormatMetadata);\n\n    fm->numNibbles = 0;\n    fm->numPrintFragments = 1;\n    fm->logLevel = NOTICE;\n    fm->lineNumber = 24;\n    fm->filenameLength = 25;\n\n    buffer = stpcpy(buffer, \"src/testHelper/client.cc\") + 1;\n\n            // Fragment 0\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\"Notice Level\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = NONE;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\"Notice Level\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \"Notice Level\") + 1;\n}\r\n\r\n",
            "filename": "src/testHelper/client.cc",
            "fmtString": "Notice Level",
            "linenum": 24,
            "logLevel": "NOTICE",
            "recordFnDecl": "void __syang0__fl__Notice32Level__src47testHelper47client46cc__24__(NanoLog::LogLevel level, const char* fmtStr )",
            "recordFnDef": "\ninline void __syang0__fl__Notice32Level__src47testHelper47client46cc__24__(NanoLog::LogLevel level, const char* fmtStr ) {\n    extern const uint32_t __fmtId__Notice32Level__src47testHelper47client46cc__24__;\n\n    if (level > NanoLog::getLogLevel())\n        return;\n\n    uint64_t timestamp = PerfUtils::Cycles::rdtsc();\n    ;\n    size_t allocSize =   sizeof(NanoLogInternal::Log::UncompressedEntry);\n    NanoLogInternal::Log::UncompressedEntry *re = reinterpret_cast<NanoLogInternal::Log::UncompressedEntry*>(NanoLogInternal::RuntimeLogger::reserveAlloc(allocSize));\n\n    re->fmtId = __fmtId__Notice32Level__src47testHelper47client46cc__24__;\n    re->timestamp = timestamp;\n    re->entrySize = static_cast<uint32_t>(allocSize);\n\n    char *buffer = re->argData;\n\n    // Record the non-string arguments\n    \n\n    // Record the strings (if any) at the end of the entry\n    \n\n    // Make the entry visible\n    NanoLogInternal::RuntimeLogger::finishAlloc(allocSize);\n}\n",
            "recordFnName": "__syang0__fl__Notice32Level__src47testHelper47client46cc__24__"
        },
        "__Simple32log32message32with32032parameters__src47testHelper47client46cc__20__": {
            "compilationUnit": "src/testHelper/client.cc",
            "compressFnDef": "\ninline ssize_t\ncompressArgs__Simple32log32message32with32032parameters__src47testHelper47client46cc__20__(NanoLogInternal::Log::UncompressedEntry *re, char* out) {\n    char *originalOutPtr = out;\n\n    // Allocate nibbles\n    BufferUtils::TwoNibbles *nib = reinterpret_cast<BufferUtils::TwoNibbles*>(out);\n    out += 0;\n\n    char *args = re->argData;\n\n    // Read back all the primitives\n    \n\n    // Pack all the primitives\n    \n\n    if (false) {\n        // memcpy all the strings without compression\n        size_t stringBytes = re->entrySize - ( 0)\n                                            - sizeof(NanoLogInternal::Log::UncompressedEntry);\n        if (stringBytes > 0) {\n            memcpy(out, args, stringBytes);\n            out += stringBytes;\n        }\n    }\n\n    return out - originalOutPtr;\n}\n",
            "compressFnName": "compressArgs__Simple32log32message32with32032parameters__src47testHelper47client46cc__20__",
            "decompressFnDef": "\ninline void\ndecompressPrintArgs__Simple32log32message32with32032parameters__src47testHelper47client46cc__20__ (const char **in,\n                        FILE *outputFd,\n                        void (*aggFn)(const char*, ...)) {\n    BufferUtils::TwoNibbles nib[0];\n    memcpy(&nib, (*in), 0);\n    (*in) += 0;\n\n    // Unpack all the non-string argments\n    \n\n    // Find all the strings\n    \n\n    const char *fmtString = \"Simple log message with 0 parameters\";\n    const char *filename = \"src/testHelper/client.cc\";\n    const int linenum = 20;\n    const NanoLog::LogLevel logLevel = NOTICE;\n\n    if (outputFd)\n        fprintf(outputFd, \"Simple log message with 0 parameters\" \"\\r\\n\" );\n\n    if (aggFn)\n        (*aggFn)(\"Simple log message with 0 parameters\" );\n}\n",
            "decompressFnName": "decompressPrintArgs__Simple32log32message32with32032parameters__src47testHelper47client46cc__20__",
            "dictionaryFragment": "\n{\n    // src/testHelper/client.cc:20 - \"Simple log message with 0 parameters\"\n    FormatMetadata *fm;\n    PrintFragment *pf;\n    if (buffer + sizeof(FormatMetadata) + 25 >= endOfBuffer)\n        return -1;\n\n    fm = reinterpret_cast<FormatMetadata*>(buffer);\n    buffer += sizeof(FormatMetadata);\n\n    fm->numNibbles = 0;\n    fm->numPrintFragments = 1;\n    fm->logLevel = NOTICE;\n    fm->lineNumber = 20;\n    fm->filenameLength = 25;\n\n    buffer = stpcpy(buffer, \"src/testHelper/client.cc\") + 1;\n\n            // Fragment 0\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\"Simple log message with 0 parameters\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = NONE;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\"Simple log message with 0 parameters\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \"Simple log message with 0 parameters\") + 1;\n}\r\n\r\n",
            "filename": "src/testHelper/client.cc",
            "fmtString": "Simple log message with 0 parameters",
            "linenum": 20,
            "logLevel": "NOTICE",
            "recordFnDecl": "void __syang0__fl__Simple32log32message32with32032parameters__src47testHelper47client46cc__20__(NanoLog::LogLevel level, const char* fmtStr )",
            "recordFnDef": "\ninline void __syang0__fl__Simple32log32message32with32032parameters__src47testHelper47client46cc__20__(NanoLog::LogLevel level, const char* fmtStr ) {\n    extern const uint32_t __fmtId__Simple32log32message32with32032parameters__src47testHelper47client46cc__20__;\n\n    if (level > NanoLog::getLogLevel())\n        return;\n\n    uint64_t timestamp = PerfUtils::Cycles::rdtsc();\n    ;\n    size_t allocSize =   sizeof(NanoLogInternal::Log::UncompressedEntry);\n    NanoLogInternal::Log::UncompressedEntry *re = reinterpret_cast<NanoLogInternal::Log::UncompressedEntry*>(NanoLogInternal::RuntimeLogger::reserveAlloc(allocSize));\n\n    re->fmtId = __fmtId__Simple32log32message32with32032parameters__src47testHelper47client46cc__20__;\n    re->timestamp = timestamp;\n    re->entrySize = static_cast<uint32_t>(allocSize);\n\n    char *buffer = re->argData;\n\n    // Record the non-string arguments\n    \n\n    // Record the strings (if any) at the end of the entry\n    \n\n    // Make the entry visible\n    NanoLogInternal::RuntimeLogger::finishAlloc(allocSize);\n}\n",
            "recordFnName": "__syang0__fl__Simple32log32message32with32032parameters__src47testHelper47client46cc__20__"
        },
        "__This32is32a32string3237s__src47testHelper47client46cc__21__": {
            "compilationUnit": "src/testHelper/client.cc",
            "compressFnDef": "\ninline ssize_t\ncompressArgs__This32is32a32string3237s__src47testHelper47client46cc__21__(NanoLogInternal::Log::UncompressedEntry *re, char* out) {\n    char *originalOutPtr = out;\n\n    // Allocate nibbles\n    BufferUtils::TwoNibbles *nib = reinterpret_cast<BufferUtils::TwoNibbles*>(out);\n    out += 0;\n\n    char *args = re->argData;\n\n    // Read back all the primitives\n    \n\n    // Pack all the primitives\n    \n\n    if (true) {\n        // memcpy all the strings without compression\n        size_t stringBytes = re->entrySize - ( 0)\n                                            - sizeof(NanoLogInternal::Log::UncompressedEntry);\n        if (stringBytes > 0) {\n            memcpy(out, args, stringBytes);\n            out += stringBytes;\n        }\n    }\n\n    return out - originalOutPtr;\n}\n",
            "compressFnName": "compressArgs__This32is32a32string3237s__src47testHelper47client46cc__21__",
            "decompressFnDef": "\ninline void\ndecompressPrintArgs__This32is32a32string3237s__src47testHelper47client46cc__21__ (const char **in,\n                        FILE *outputFd,\n                        void (*aggFn)(const char*, ...)) {\n    BufferUtils::TwoNibbles nib[0];\n    memcpy(&nib, (*in), 0);\n    (*in) += 0;\n\n    // Unpack all the non-string argments\n    \n\n    // Find all the strings\n    \n                const char* arg0 = reinterpret_cast<const char*>(*in);\n                (*in) += (strlen(arg0) + 1)*sizeof(*arg0); // +1 for null terminator\n            \n\n    const char *fmtString = \"This is a string %s\";\n    const char *filename = \"src/testHelper/client.cc\";\n    const int linenum = 21;\n    const NanoLog::LogLevel logLevel = NOTICE;\n\n    if (outputFd)\n        fprintf(outputFd, \"This is a string %s\" \"\\r\\n\" , arg0);\n\n    if (aggFn)\n        (*aggFn)(\"This is a string %s\" , arg0);\n}\n",
            "decompressFnName": "decompressPrintArgs__This32is32a32string3237s__src47testHelper47client46cc__21__",
            "dictionaryFragment": "\n{\n    // src/testHelper/client.cc:21 - \"This is a string %s\"\n    FormatMetadata *fm;\n    PrintFragment *pf;\n    if (buffer + sizeof(FormatMetadata) + 25 >= endOfBuffer)\n        return -1;\n\n    fm = reinterpret_cast<FormatMetadata*>(buffer);\n    buffer += sizeof(FormatMetadata);\n\n    fm->numNibbles = 0;\n    fm->numPrintFragments = 1;\n    fm->logLevel = NOTICE;\n    fm->lineNumber = 21;\n    fm->filenameLength = 25;\n\n    buffer = stpcpy(buffer, \"src/testHelper/client.cc\") + 1;\n\n            // Fragment 0\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\"This is a string %s\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = const_char_ptr_t;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\"This is a string %s\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \"This is a string %s\") + 1;\n}\r\n\r\n",
            "filename": "src/testHelper/client.cc",
            "fmtString": "This is a string %s",
            "linenum": 21,
            "logLevel": "NOTICE",
            "recordFnDecl": "void __syang0__fl__This32is32a32string3237s__src47testHelper47client46cc__21__(NanoLog::LogLevel level, const char* fmtStr , const char* arg0)",
            "recordFnDef": "\ninline void __syang0__fl__This32is32a32string3237s__src47testHelper47client46cc__21__(NanoLog::LogLevel level, const char* fmtStr , const char* arg0) {\n    extern const uint32_t __fmtId__This32is32a32string3237s__src47testHelper47client46cc__21__;\n\n    if (level > NanoLog::getLogLevel())\n        return;\n\n    uint64_t timestamp = PerfUtils::Cycles::rdtsc();\n    size_t str0Len = 1 + strlen(arg0);;\n    size_t allocSize =  str0Len +  sizeof(NanoLogInternal::Log::UncompressedEntry);\n    NanoLogInternal::Log::UncompressedEntry *re = reinterpret_cast<NanoLogInternal::Log::UncompressedEntry*>(NanoLogInternal::RuntimeLogger::reserveAlloc(allocSize));\n\n    re->fmtId = __fmtId__This32is32a32string3237s__src47testHelper47client46cc__21__;\n    re->timestamp = timestamp;\n    re->entrySize = static_cast<uint32_t>(allocSize);\n\n    char *buffer = re->argData;\n\n    // Record the non-string arguments\n    \n\n    // Record the strings (if any) at the end of the entry\n    memcpy(buffer, arg0, str0Len); buffer += str0Len;*(reinterpret_cast<std::remove_const<typename std::remove_pointer<decltype(arg0)>::type>::type*>(buffer) - 1) = L'\\0';\n\n    // Make the entry visible\n    NanoLogInternal::RuntimeLogger::finishAlloc(allocSize);\n}\n",
            "recordFnName": "__syang0__fl__This32is32a32string3237s__src47testHelper47client46cc__21__"
        },
        "__Warning32Level__src47testHelper47client46cc__25__": {
            "compilationUnit": "src/testHelper/client.cc",
            "compressFnDef": "\ninline ssize_t\ncompressArgs__Warning32Level__src47testHelper47client46cc__25__(NanoLogInternal::Log::UncompressedEntry *re, char* out) {\n    char *originalOutPtr = out;\n\n    // Allocate nibbles\n    BufferUtils::TwoNibbles *nib = reinterpret_cast<BufferUtils::TwoNibbles*>(out);\n    out += 0;\n\n    char *args = re->argData;\n\n    // Read back all the primitives\n    \n\n    // Pack all the primitives\n    \n\n    if (false) {\n        // memcpy all the strings without compression\n        size_t stringBytes = re->entrySize - ( 0)\n                                            - sizeof(NanoLogInternal::Log::UncompressedEntry);\n        if (stringBytes > 0) {\n            memcpy(out, args, stringBytes);\n            out += stringBytes;\n        }\n    }\n\n    return out - originalOutPtr;\n}\n",
            "compressFnName": "compressArgs__Warning32Level__src47testHelper47client46cc__25__",
            "decompressFnDef": "\ninline void\ndecompressPrintArgs__Warning32Level__src47testHelper47client46cc__25__ (const char **in,\n                        FILE *outputFd,\n                        void (*aggFn)(const char*, ...)) {\n    BufferUtils::TwoNibbles nib[0];\n    memcpy(&nib, (*in), 0);\n    (*in) += 0;\n\n    // Unpack all the non-string argments\n    \n\n    // Find all the strings\n    \n\n    const char *fmtString = \"Warning Level\";\n    const char *filename = \"src/testHelper/client.cc\";\n    const int linenum = 25;\n    const NanoLog::LogLevel logLevel = WARNING;\n\n    if (outputFd)\n        fprintf(outputFd, \"Warning Level\" \"\\r\\n\" );\n\n    if (aggFn)\n        (*aggFn)(\"Warning Level\" );\n}\n",
            "decompressFnName": "decompressPrintArgs__Warning32Level__src47testHelper47client46cc__25__",
            "dictionaryFragment": "\n{\n    // src/testHelper/client.cc:25 - \"Warning Level\"\n    FormatMetadata *fm;\n    PrintFragment *pf;\n    if (buffer + sizeof(FormatMetadata) + 25 >= endOfBuffer)\n        return -1;\n\n    fm = reinterpret_cast<FormatMetadata*>(buffer);\n    buffer += sizeof(FormatMetadata);\n\n    fm->numNibbles = 0;\n    fm->numPrintFragments = 1;\n    fm->logLevel = WARNING;\n    fm->lineNumber = 25;\n    fm->filenameLength = 25;\n\n    buffer = stpcpy(buffer, \"src/testHelper/client.cc\") + 1;\n\n            // Fragment 0\n            if (buffer + sizeof(PrintFragment)\n                        + sizeof(\"Warning Level\")/sizeof(char) >= endOfBuffer)\n                return -1;\n\n            pf = reinterpret_cast<PrintFragment*>(buffer);\n            buffer += sizeof(PrintFragment);\n\n            pf->argType = NONE;\n            pf->hasDynamicWidth = false;\n            pf->hasDynamicPrecision = false;\n            pf->fragmentLength = sizeof(\"Warning Level\")/sizeof(char);\n\n            buffer = stpcpy(buffer, \"Warning Level\") + 1;\n}\r\n\r\n",
            "filename": "src/testHelper/client.cc",
            "fmtString": "Warning Level",
            "linenum": 25,
            "logLevel": "WARNING",
            "recordFnDecl": "void __syang0__fl__Warning32Level__src47testHelper47client46cc__25__(NanoLog::LogLevel level, const char* fmtStr )",
            "recordFnDef": "\ninline void __syang0__fl__Warning32Level__src47testHelper47client46cc__25__(NanoLog::LogLevel level, const char* fmtStr ) {\n    extern const uint32_t __fmtId__Warning32Level__src47testHelper47client46cc__25__;\n\n    if (level > NanoLog::getLogLevel())\n        return;\n\n    uint64_t timestamp = PerfUtils::Cycles::rdtsc();\n    ;\n    size_t allocSize =   sizeof(NanoLogInternal::Log::UncompressedEntry);\n    NanoLogInternal::Log::UncompressedEntry *re = reinterpret_cast<NanoLogInternal::Log::UncompressedEntry*>(NanoLogInternal::RuntimeLogger::reserveAlloc(allocSize));\n\n    re->fmtId = __fmtId__Warning32Level__src47testHelper47client46cc__25__;\n    re->timestamp = timestamp;\n    re->entrySize = static_cast<uint32_t>(allocSize);\n\n    char *buffer = re->argData;\n\n    // Record the non-string arguments\n    \n\n    // Record the strings (if any) at the end of the entry\n    \n\n    // Make the entry visible\n    NanoLogInternal::RuntimeLogger::finishAlloc(allocSize);\n}\n",
            "recordFnName": "__syang0__fl__Warning32Level__src47testHelper47client46cc__25__"
        }
    }
}